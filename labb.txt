CV LAB PROGRAMS

1. Perform basic Image Handling and processing operations on the image.  
• Read an image in python  and  Convert an Image to Grayscale 
CODE:
import cv2

# Read the image
image = cv2.imread('C:/Users/dilli/OneDrive/Documents/Computer Vision/Exp 1.png')  # Replace with your image filename

# Show the original image
cv2.imshow('Original Image', image)

# Convert to grayscale
gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

# Show the grayscale image
cv2.imshow('Grayscale Image', gray_image)

# Wait for a key press and close all windows
cv2.waitKey(0)
cv2.destroyAllWindows()


2. Perform basic Image Handling and processing operations on the image
• Read an image in python  and  Convert an Image to Blur using GaussianBlur.
CODE:

import cv2


# Read your PNG image
img = cv2.imread('C:/Documents/Computer Vision/Exp 2.png')

# Safety check if image was loaded
if img is None:
    print("Error: Image not found or path is incorrect.")
else:
    blur = cv2.GaussianBlur(img, (15, 15), 0)

    cv2.imshow('Original Image', img)
    cv2.imshow('Blurred Image', blur)

    cv2.waitKey(0)
    cv2.destroyAllWindows()


3. Perform basic Image Handling and processing operations on the image
• Read an image in python  and  Convert an Image to show outline using Canny function. 
CODE:
import cv2

img = cv2.imread('C:/Documents/Computer Vision/Exp 3.jpg')
edges = cv2.Canny(img, 100, 200)

cv2.imshow('Original Image', img)
cv2.imshow('Canny Edges', edges)

cv2.waitKey(0)
cv2.destroyAllWindows()


4. Perform basic Image Handling and processing operations on the image
• Read an image in python  and  Dilate an Image using Dilate function.
CODE:
import cv2
import numpy as np

img = cv2.imread('C:/Documents/Computer Vision/Exp 4.jpg')
kernel = np.ones((5,5), np.uint8)
dilated = cv2.dilate(img, kernel, iterations=1)

cv2.imshow('Original Image', img)
cv2.imshow('Dilated Image', dilated)

cv2.waitKey(0)
cv2.destroyAllWindows()


5. Perform basic Image Handling and processing operations on the image
• Read an image in python  and  Erode an Image using erode function.
CODE:
import cv2
import numpy as np

img = cv2.imread('C:/Documents/Computer Vision/Exp 5.jpg')
kernel = np.ones((5,5), np.uint8)
eroded = cv2.erode(img, kernel, iterations=1)

cv2.imshow('Original Image', img)
cv2.imshow('Eroded Image', eroded)

cv2.waitKey(0)
cv2.destroyAllWindows()


6. Perform basic video processing operations on the captured video
• Read captured video in python  and  display the video, in slow motion and in fast motion.
CODE:

import cv2

cap = cv2.VideoCapture('"C:\Documents\Computer Vision\WIN_20241118_12_23_30_Pro.mp4"')

while True:
    ret, frame = cap.read()
    if not ret:
        break

    cv2.imshow('Video', frame)
    
    # Wait 30ms for normal speed
    if cv2.waitKey(30) & 0xFF == ord('q'):
        break

cap.release()
cv2.destroyAllWindows()


7. Capture video from web Camera and  Display the video, in slow motion and in fast motion.
CODE:
import cv2

# Open the webcam
cap = cv2.VideoCapture(0)

if not cap.isOpened():
    print("Error: Cannot open webcam.")
else:
    print("Press 's' for slow motion, 'f' for fast motion, 'q' to quit.")

    delay = 30  # normal speed

    while True:
        ret, frame = cap.read()
        if not ret:
            break

        cv2.imshow('Webcam Video', frame)

        key = cv2.waitKey(delay) & 0xFF
        if key == ord('q'):
            break
        elif key == ord('s'):
            delay = 100  # slow motion (100 ms delay)
        elif key == ord('f'):
            delay = 1    # fast motion (1 ms delay)

    cap.release()
    cv2.destroyAllWindows()


8. Scaling an image to its Bigger and Smaller sizes.
CODE:
import cv2

# Load the image
img = cv2.imread('Exp 1.png')

if img is None:
    print("Error: Image not found.")
else:
    # Resize to bigger size (double)
    bigger = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_LINEAR)

    # Resize to smaller size (half)
    smaller = cv2.resize(img, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_AREA)

    # Show images
    cv2.imshow('Original Image', img)
    cv2.imshow('Bigger Image', bigger)
    cv2.imshow('Smaller Image', smaller)

    cv2.waitKey(0)
    cv2.destroyAllWindows()


9.Perform Rotation of an image to clockwise and counter clockwise direction.
CODE:
import cv2
image = cv2.imread("C:\\Users\\shanm\\Pictures\\Screenshots\\Screenshot 2025-06-24 142941.png")
small_image = cv2.resize(image, None, fx=0.5, fy=0.5, interpolation=cv2.INTER_AREA)
large_image = cv2.resize(image, None, fx=2.0, fy=2.0, interpolation=cv2.INTER_CUBIC)
cv2.imshow("Original Image", image)
cv2.imshow("Smaller Image", small_image)
cv2.imshow("Larger Image", large_image)
cv2.waitKey(0)
cv2.destroyAllWindows()


10. Perform moving of an image from one place to another.
CODE:
import cv2
image = cv2.imread("C:\\Users\\shanm\\Pictures\\Screenshots\\Screenshot 2025-06-29 165134.png")
rotated = cv2.rotate(image, cv2.ROTATE_90_CLOCKWISE)
cv2.imshow("Rotated 90° Clockwise", rotated)
cv2.waitKey(0)
cv2.destroyAllWindows()


11. Perform Affine Transformation on the image.
CODE:
img = cv2.imread('C:/Documents/Computer Vision/Exp 11.png')
rows, cols, ch = img.shape

pts1 = np.float32([[56,65],[368,52],[28,387],[389,390]])
pts2 = np.float32([[0,0],[300,0],[0,300],[300,300]])

M = cv2.getPerspectiveTransform(pts1, pts2)
dst = cv2.warpPerspective(img, M, (300,300))

cv2.imshow('Perspective Transform', dst)
cv2.waitKey(0)
cv2.destroyAllWindows()


12. Perform Perspective Transformation on the image.
CODE:
img = cv2.imread('C:/Documents/Computer Vision/Exp 1.png')
rows, cols, ch = img.shape

pts1 = np.float32([[56,65],[368,52],[28,387],[389,390]])
pts2 = np.float32([[0,0],[300,0],[0,300],[300,300]])

M = cv2.getPerspectiveTransform(pts1, pts2)
dst = cv2.warpPerspective(img, M, (300,300))

cv2.imshow('Perspective Transform', dst)
cv2.waitKey(0)
cv2.destroyAllWindows()


13. Perform Perspective Transformation on the Video.
CODE:
import cv2

# Replace the path below with the actual image file path
image_path = r"C:\Users\shanm\Pictures\Screenshots\Screenshot 2025-06-29 121126.png"

# Load the image
image = cv2.imread(image_path)

# Check if the image is loaded properly
if image is None:
    print("Error: Image not found or path is incorrect!")
else:
    # Convert to grayscale
    gray_image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)

    # Apply Canny Edge Detection
    edges = cv2.Canny(gray_image, 100, 200)

    # Display the original and processed images
    cv2.imshow('Original Image', image)
    cv2.imshow('Canny Edge Detection', edges)

    cv2.waitKey(0)
    cv2.destroyAllWindows()

14. Perform transformation using Homography matrix.
CODE:
import cv2
import numpy as np
image = cv2.imread("C:\\Users\\shanm\\Pictures\\Screenshots\\Screenshot 2025-06-29 165122.png")
rows, cols = image.shape[:2]
pts1 = np.float32([[50, 50], [200, 50], [50, 200], [200, 200]])
pts2 = np.float32([[10, 100], [220, 50], [100, 250], [220, 220]])
matrix = cv2.getPerspectiveTransform(pts1, pts2)
result = cv2.warpPerspective(image, matrix, (cols, rows))
cv2.imshow("Original Image", image)
cv2.imshow("Perspective Transformed Image", result)
cv2.waitKey(0)
cv2.destroyAllWindows()


15. Perform transformation using Direct Linear Transformation.
CODE:'
import cv2
import numpy as np
image = cv2.imread("C:\\Users\\shanm\\Pictures\\Screenshots\\Screenshot 2025-06-29 121126.png")
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
gray = np.float32(gray)
dst = cv2.cornerHarris(gray, blockSize=2, ksize=3, k=0.04)
dst = cv2.dilate(dst, None)
image[dst > 0.01 * dst.max()] = [0, 0, 255]
cv2.imshow("Harris Corners", image)
cv2.waitKey(0)
cv2.destroyAllWindows()


16. Perform Edge detection using canny method
CODE:
import cv2
import numpy as np
image = cv2.imread("C:\\Users\\shanm\\Pictures\\Screenshots\\Screenshot 2025-06-29 165122.png")
gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
sobel_x = cv2.Sobel(gray, cv2.CV_64F, 1, 0, ksize=3)  
sobel_y = cv2.Sobel(gray, cv2.CV_64F, 0, 1, ksize=3)  
sobel_combined = cv2.magnitude(sobel_x, sobel_y)
sobel_combined = cv2.convertScaleAbs(sobel_combined)
cv2.imshow("Original Image", image)
cv2.imshow("Sobel - X Direction", cv2.convertScaleAbs(sobel_x))
cv2.imshow("Sobel - Y Direction", cv2.convertScaleAbs(sobel_y))
cv2.imshow("Sobel - Combined", sobel_combined)
cv2.waitKey(0)
cv2.destroyAllWindows()

17. Perform Edge detection using Sobel Matrix along X axis
CODE:
import cv2
image = cv2.imread("C:\\Users\\shanm\\Pictures\\Screenshots\\Screenshot 2025-06-29 165122.png")
watermarked = image.copy()
cv2.putText(watermarked, "DHARSHINI", (20, 50), cv2.FONT_HERSHEY_SIMPLEX, 
            1, (255, 255, 255), 2, cv2.LINE_AA)
cv2.imshow("Watermarked Image", watermarked)
cv2.waitKey(0)
cv2.destroyAllWindows()


18. Perform Edge detection using Sobel Matrix along Y axis
CODE:
import cv2
image = cv2.imread("C:\\Users\\shanm\\Pictures\\Screenshots\\Screenshot 2025-06-24 143240.png")
roi = image[100:165, 150:250]
image[0:65, 0:100] = roi
cv2.imshow("Original with ROI Pasted", image)
cv2.waitKey(0)
cv2.destroyAllWindows()


19. Perform Edge detection using Sobel Matrix along XY axis
CODE:
import cv2
import numpy as np
image = cv2.imread("C:\\Users\\shanm\\Pictures\\Screenshots\\Screenshot 2025-06-23 105218.png", 0)
kernel = np.ones((5, 5), np.uint8)
eroded_image = cv2.erode(image, kernel, iterations=1)
cv2.imshow("Original Image", image)
cv2.imshow("Eroded Image", eroded_image)
cv2.waitKey(0)
cv2.destroyAllWindows()


20. Perform Sharpening of Image using Laplacian mask with negative center coefficient.
CODE:
import cv2
import numpy as np
image = cv2.imread("C:\\Users\\shanm\\Pictures\\Screenshots\\Screenshot 2025-06-24 142941.png", 0)
kernel = np.ones((5, 5), np.uint8)
dilated_image = cv2.dilate(image, kernel, iterations=1)
cv2.imshow("Original Image", image)
cv2.imshow("Dilated Image", dilated_image)
cv2.waitKey(0)
cv2.destroyAllWindows()


21. Perform Sharpening of Image using Laplacian mask implemented with an extension of
diagonal neighbors,
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 1.png', 0)
kernel = np.array([[1, 1, 1],
                   [1, -8, 1],
                   [1, 1, 1]])

sharpened = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Laplacian Sharpened (Diagonal)', sharpened)
cv2.waitKey(0)
cv2.destroyAllWindows()


22. Perform Sharpening of Image using Laplacian mask with positive center coefficient.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 2.jpg', 0)
kernel = np.array([[0, -1, 0],
                   [-1, 5, -1],
                   [0, -1, 0]])

sharpened = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Positive Center Laplacian', sharpened)
cv2.waitKey(0)
cv2.destroyAllWindows()


23.Perform Sharpening of Image using unsharp masking.
CODE:
import cv2

img = cv2.imread('Exp 3.jpg')
blur = cv2.GaussianBlur(img, (9,9), 10.0)
unsharp = cv2.addWeighted(img, 1.5, blur, -0.5, 0)

cv2.imshow('Original Image', img)
cv2.imshow('Unsharp Masking', unsharp)
cv2.waitKey(0)
cv2.destroyAllWindows()


24. Perform Sharpening of Image using High-Boost Masks.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 3.jpg', 0)
A = 4
kernel = np.array([[0, -1, 0],
                   [-1, A, -1],
                   [0, -1, 0]])

high_boost = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('High-Boost Masking', high_boost)
cv2.waitKey(0)
cv2.destroyAllWindows()


25. Perform Sharpening of Image using Gradient masking.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 4.jpg', 0)
kernel = np.array([[-1, -2, -1],
                   [ 0,  0,  0],
                   [ 1,  2,  1]])

gradient_sharpen = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Gradient Masking', gradient_sharpen)
cv2.waitKey(0)
cv2.destroyAllWindows()


26. Insert water marking to the image using OpenCV.
CODE:
import cv2

img = cv2.imread('Exp 4.jpg')
font = cv2.FONT_HERSHEY_SIMPLEX
cv2.putText(img, '© Sakthi Manoj', (10,50), font, 1, (255,255,255), 2, cv2.LINE_AA)

cv2.imshow('Watermarked Image', img)
cv2.waitKey(0)
cv2.destroyAllWindows()

27. Do Cropping, Copying and pasting image inside another image using OpenCV.
CODE:
import cv2

img = cv2.imread('Exp 1.png')

# Check image size
h, w = img.shape[:2]

# Define region of interest within available size
roi = img[50:100, 50:100]  # 50×50 cropped region

# Paste it at 120,120 if possible
if h >= 170 and w >= 170:
    img[120:170, 120:170] = roi
else:
    print("Image too small for paste operation.")

cv2.imshow('Crop & Paste', img)
cv2.waitKey(0)
cv2.destroyAllWindows()


28. Find the boundary of the image using Convolution kernel for the given image.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 3.jpg', 0)
kernel = np.array([[-1, -1, -1],
                   [-1,  8, -1],
                   [-1, -1, -1]])

boundary = cv2.filter2D(img, -1, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Boundary Detection', boundary)
cv2.waitKey(0)
cv2.destroyAllWindows()


29. Morphological operations based on OpenCV using Erosion technique.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 3.jpg', 0)
kernel = np.ones((5,5), np.uint8)
eroded = cv2.erode(img, kernel, iterations=1)

cv2.imshow('Original Image', img)
cv2.imshow('Eroded Image', eroded)
cv2.waitKey(0)
cv2.destroyAllWindows()


30. Morphological operations based on OpenCV using Dilation technique.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 1.png', 0)
kernel = np.ones((5,5), np.uint8)
dilated = cv2.dilate(img, kernel, iterations=1)

cv2.imshow('Original Image', img)
cv2.imshow('Dilated Image', dilated)
cv2.waitKey(0)
cv2.destroyAllWindows()



31. Morphological operations based on OpenCV using Opening technique.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 4.jpg', 0)
kernel = np.ones((5,5), np.uint8)
opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Opening Operation', opening)
cv2.waitKey(0)
cv2.destroyAllWindows()


32. Morphological operations based on OpenCV using Closing technique.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 3.jpg', 0)
kernel = np.ones((5,5), np.uint8)
closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Closing Operation', closing)
cv2.waitKey(0)
cv2.destroyAllWindows()


33. Morphological operations based on OpenCV using Morphological Gradient technique.
CODE:
import cv2
import numpy as np

img = cv2.imread('Exp 4.jpg', 0)
kernel = np.ones((5,5), np.uint8)
gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)

cv2.imshow('Original Image', img)
cv2.imshow('Morphological Gradient', gradient)
cv2.waitKey(0)
cv2.destroyAllWindows()


34. Morphological operations based on OpenCV using Top hat technique.
CODE:
import cv2
import numpy as np

# Load image
img_original = cv2.imread('Exp 3.jpg')

# Check if image loaded successfully
if img_original is None:
    print("Error: Image not found or path is incorrect.")
else:
    # Make a copy to work on
    img = img_original.copy()

    # Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    gray = np.float32(gray)

    # Apply Harris Corner Detection
    dst = cv2.cornerHarris(gray, blockSize=2, ksize=3, k=0.04)

    # Result is dilated for marking corners
    dst = cv2.dilate(dst, None)

    # Threshold for optimal value and mark in red
    img[dst > 0.01 * dst.max()] = [0, 0, 255]

    # Display images
    cv2.imshow('Original Image', img_original)
    cv2.imshow('Harris Corners Detected', img)

    cv2.waitKey(0)
    cv2.destroyAllWindows()



35. Morphological operations based on OpenCV using Black hat technique.
CODE:
import cv2
import numpy as np

# Load image
img_original = cv2.imread('Exp 4.jpg')

# Check if image loaded successfully
if img_original is None:
    print("Error: Image not found or path is incorrect.")
else:
    # Make a copy for marking corners
    img = img_original.copy()

    # Convert to grayscale
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # Detect corners using Shi-Tomasi method
    corners = cv2.goodFeaturesToTrack(gray, maxCorners=100, qualityLevel=0.01, minDistance=10)

    # Convert to integer values
    corners = corners.astype(int)

    # Draw small circles at each corner
    for corner in corners:
        x, y = corner.ravel()
        cv2.circle(img, (x, y), 4, (0, 255, 0), -1)

    # Display images
    cv2.imshow('Original Image', img_original)
    cv2.imshow('Shi-Tomasi Corners Detected', img)

    cv2.waitKey(0)
    cv2.destroyAllWindows()


36. Recognise watch from the given image by general Object recognition using OpenCV.
CODE:
import cv2

# Load reference image (the watch) and the scene image
img1 = cv2.imread("watch.jpg", cv2.IMREAD_GRAYSCALE)   # Reference image
img2 = cv2.imread("scene.jpg", cv2.IMREAD_GRAYSCALE)   # Scene image

# Initialize ORB detector
orb = cv2.ORB_create()

# Detect keypoints and descriptors
kp1, des1 = orb.detectAndCompute(img1, None)
kp2, des2 = orb.detectAndCompute(img2, None)

# Create BFMatcher (Brute Force)
bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)

# Match descriptors
matches = bf.match(des1, des2)

# Sort matches by distance (lower is better)
matches = sorted(matches, key=lambda x: x.distance)

# Draw top 30 matches
result = cv2.drawMatches(img1, kp1, img2, kp2, matches[:30], None, flags=2)

# Show result
cv2.imshow("Watch Recognition", result)
cv2.waitKey(0)
cv2.destroyAllWindows()


37. Using Opencv play Video in Reverse mode.
CODE:
import cv2

# Load the video
cap = cv2.VideoCapture('your_video.mp4')  # Replace with your video file

# Get total number of frames
frame_count = int(cap.get(cv2.CAP_PROP_FRAME_COUNT))

# Loop through the video in reverse
for i in range(frame_count - 1, -1, -1):
    cap.set(cv2.CAP_PROP_POS_FRAMES, i)  # Go to frame i
    ret, frame = cap.read()
    
    if not ret:
        break

    cv2.imshow("Reverse Video", frame)
    
    if cv2.waitKey(30) & 0xFF == ord('q'):
        break

# Release resources
cap.release()
cv2.destroyAllWindows()


38. Face Detection using Opencv.
CODE:
import cv2

# Load pre-trained face detection model
face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades + "haarcascade_frontalface_default.xml")

# Start webcam
cap = cv2.VideoCapture(0)

while True:
    # Read each frame
    ret, frame = cap.read()
    if not ret:
        break

    # Convert to grayscale (face detection works on gray images)
    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

    # Detect faces
    faces = face_cascade.detectMultiScale(gray, scaleFactor=1.1, minNeighbors=5)

    # Draw rectangle around detected faces
    for (x, y, w, h) in faces:
        cv2.rectangle(frame, (x, y), (x+w, y+h), (255, 0, 0), 2)

    # Show the frame
    cv2.imshow("Face Detection", frame)

    # Exit on 'q' key
    if cv2.waitKey(1) & 0xFF == ord('q'):
        break

# Release and close
cap.release()
cv2.destroyAllWindows()



39. Vehicle Detection in a Video frame using OpenCV .
CDOE:
import cv2
import numpy as np

img = cv2.imread('Exp 3.jpg', 0)

# Horizontal kernel
kernelx = np.array([[1, 0, -1],
                    [1, 0, -1],
                    [1, 0, -1]])

# Vertical kernel
kernely = np.array([[1, 1, 1],
                    [0, 0, 0],
                    [-1, -1, -1]])

prewittx = cv2.filter2D(img, -1, kernelx)
prewitty = cv2.filter2D(img, -1, kernely)

cv2.imshow('Original Image', img)
cv2.imshow('Prewitt X', prewittx)
cv2.imshow('Prewitt Y', prewitty)
cv2.waitKey(0)
cv2.destroyAllWindows()


40. Draw Rectangular shape and extract objects.
CODE:
import cv2

# Load image
img = cv2.imread("objects.jpg")  # Replace with your image
original = img.copy()

# Convert to grayscale
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

# Apply thresholding to binarize
_, thresh = cv2.threshold(gray, 127, 255, cv2.THRESH_BINARY_INV)

# Find contours
contours, _ = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

object_count = 0

# Loop through contours
for cnt in contours:
    x, y, w, h = cv2.boundingRect(cnt)  # Get bounding box
    cv2.rectangle(original, (x, y), (x + w, y + h), (0, 255, 0), 2)  # Draw rectangle

    # Crop the object
    cropped = img[y:y+h, x:x+w]
    cv2.imshow(f'Object {object_count}', cropped)
    object_count += 1

# Show original image with rectangles
cv2.imshow("Detected Objects", original)
cv2.waitKey(0)
cv2.destroyAllWindows()
